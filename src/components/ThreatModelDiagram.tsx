'use client'

import React from 'react'
import { Bot, Database, Server, Shield, Globe, Code } from 'lucide-react'
import { useRouter } from 'next/navigation'

interface Node {
    id: string
    type: string
    label: string
    icon?: React.ElementType
    color?: string
    size?: number
}

interface Edge {
    from: string
    to: string
    label?: string
    dashed?: boolean
}

interface ThreatModelProps {
    onVulnerabilityClick?: (vulnerability: VulnerabilityType) => void
}

interface VulnerabilityType {
    id: string
    title: string
    description: string
    position: { node: string; offset: { x: number; y: number } }
    color: string
    path?: string
}

const nodes: Node[] = [
    { id: 'client', type: 'entity', label: 'Client/Malicious Actor', icon: Globe, color: '#00ffff', size: 55 },
    { id: 'inference', type: 'service', label: 'Ingress', icon: Bot, color: '#3b82f6', size: 50 },
    { id: 'llm_service', type: 'service', label: 'LLM Service', icon: Server, color: '#ff00ff', size: 60 },
    { id: 'vector_db', type: 'storage', label: 'Vector DB', icon: Database, color: '#22c55e', size: 50 },
    { id: 'training', type: 'service', label: 'Training Pipeline', icon: Code, color: '#eab308', size: 50 },
    { id: 'security', type: 'service', label: 'Security Layer', icon: Shield, color: '#ef4444', size: 40 }
]

const edges: Edge[] = [
    { from: 'client', to: 'inference', label: 'Input' },
    { from: 'inference', to: 'llm_service', label: 'Query' },
    { from: 'llm_service', to: 'vector_db', label: 'Retrieval' },
    { from: 'llm_service', to: 'training', label: 'Fine-tuning', dashed: true },
    { from: 'security', to: 'inference', dashed: true }
]

const vulnerabilities = [
    {
        id: 'LLM01',
        title: 'Prompt Injection',
        description: 'Manipulating LLMs via crafted inputs can lead to unauthorized access, data breaches, and compromised decision-making.',
        position: { node: 'inference', offset: { x: -400, y: -80 } },
        color: '#3b82f6',
        path: '/labs/prompt-injection'
    },
    {
        id: 'LLM02',
        title: 'Sensitive Information Disclosure',
        description: 'Sensitive information can affect both the LLM and its application context. This includes personal identifiable information (PII), financial details, health records, confidential business data, security credentials, and legal documents.',
        position: { node: 'llm_service', offset: { x: 200, y: -80 } },
        color: '#ff00ff',
        path: '/labs/sensitive-info-disclosure'
    },
    {
        id: 'LLM03',
        title: 'Supply Chain',
        description: 'LLM supply chains are susceptible to various vulnerabilities, which can affect the integrity of training data, models, and deployment platforms. These risks can result in biased outputs, security breaches, or system failures.',
        position: { node: 'training', offset: { x: -200, y: 0 } },
        color: '#eab308',
        path: '/labs/supply-chain'
    },
    {
        id: 'LLM04',
        title: 'Data and Model Poisoning',
        description: 'Data poisoning occurs when pre-training, fine-tuning, or embedding data is manipulated to introduce vulnerabilities, backdoors, or biases.',
        position: { node: 'vector_db', offset: { x: 200, y: -80 } },
        color: '#22c55e',
        path: '/labs/data-poisoning'
    },
    {
        id: 'LLM05',
        title: 'Improper Output Handling',
        description: 'Improper Output Handling refers specifically to insufficient validation, sanitization, and handling of the outputs generated by large language models before they are passed downstream to other components and systems.',
        position: { node: 'inference', offset: { x: 200, y: -80 } },
        color: '#3b82f6',
        path: '/labs/improper-output'
    },
    {
        id: 'LLM06',
        title: 'Excessive Agency',
        description: 'Granting LLMs unchecked autonomy to take action can lead to unintended consequences, jeopardizing reliability, privacy, and trust.',
        position: { node: 'llm_service', offset: { x: -200, y: 150 } },
        color: '#ff00ff',
        path: '/labs/excessive-agency'
    },
    {
        id: 'LLM07',
        title: 'System Prompt Leakage',
        description: 'The system prompt leakage vulnerability in LLMs refers to the risk that the system prompts or instructions used to steer the behavior of the model can also contain sensitive information that was not intended to be discovered',
        position: { node: 'security', offset: { x: -200, y: 80 } },
        color: '#ef4444',
        path: '/labs/system-prompt-leakage'
    },
    {
        id: 'LLM08',
        title: 'Vector and Embedding Weaknesses',
        description: 'Weaknesses in how vectors and embeddings are generated, stored, or retrieved can be exploited by malicious actions (intentional or unintentional) to inject harmful content, manipulate model outputs, or access sensitive information.',
        position: { node: 'vector_db', offset: { x: 200, y: 80 } },
        color: '#22c55e',
        path: '/labs/vector-embedding-weakness'
    },
    {
        id: 'LLM09',
        title: 'Misinformation',
        description: 'Misinformation occurs when LLMs produce false or misleading information that appears credible.',
        position: { node: 'llm_service', offset: { x: 200, y: 150 } },
        color: '#ff00ff',
        path: '/labs/misinformation'
    },
    {
        id: 'LLM10',
        title: 'Unbounded Consumption',
        description: 'Unbounded Consumption occurs when a Large Language Model (LLM) application allows users to conduct excessive and uncontrolled inferences, leading to risks such as denial of service (DoS), economic losses, model theft, and service degradation',
        position: { node: 'inference', offset: { x: -200, y: -180 } },
        color: '#3b82f6',
        path: '/labs/unbounded-consumption'
    }
]

export function ThreatModelDiagram({ onVulnerabilityClick }: ThreatModelProps) {
    const router = useRouter()
    const [hoveredVuln, setHoveredVuln] = React.useState<string | null>(null)
    const [hoveredNode, setHoveredNode] = React.useState<string | null>(null)
    const svgRef = React.useRef<SVGSVGElement>(null)
    const [nodePositions] = React.useState<{ [key: string]: { x: number, y: number } }>({
        client: { x: 450, y: 50 },
        inference: { x: 450, y: 230 },
        llm_service: { x: 450, y: 400 },
        vector_db: { x: 700, y: 400 },
        training: { x: 200, y: 450 },
        security: { x: 200, y: 250 }
    })

    const getEdgePath = (from: string, to: string) => {
        const start = nodePositions[from]
        const end = nodePositions[to]
        if (!start || !end) return ''

        const dx = end.x - start.x
        const dy = end.y - start.y
        const length = Math.sqrt(dx * dx + dy * dy)

        // Adjust start and end points to start/end at node boundaries
        const startRatio = 30 / length
        const endRatio = 30 / length
        const startX = start.x + dx * startRatio
        const startY = start.y + dy * startRatio
        const endX = end.x - dx * endRatio
        const endY = end.y - dy * endRatio

        // Create curved paths with more pronounced curves
        const midX = (startX + endX) / 2
        const midY = (startY + endY) / 2
        const curviness = 40
        const controlX = midX - curviness * (endY - startY) / length
        const controlY = midY + curviness * (endX - startX) / length

        return `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`
    }

    const getVulnerabilityConnector = (nodePos: { x: number, y: number }, vulnOffset: { x: number, y: number }) => {
        const endX = nodePos.x + vulnOffset.x
        const endY = nodePos.y + vulnOffset.y

        // Calculate control points for curved line
        const dx = vulnOffset.x
        const dy = vulnOffset.y
        // Control point offset perpendicular to the line
        const perpX = -dy * 0.4
        const perpY = dx * 0.4

        const controlX = nodePos.x + vulnOffset.x * 0.5 + perpX
        const controlY = nodePos.y + vulnOffset.y * 0.5 + perpY

        return `M ${nodePos.x} ${nodePos.y} Q ${controlX} ${controlY} ${endX} ${endY}`
    }

    const handleVulnerabilityClick = (vuln: VulnerabilityType) => {
        if (vuln.path) {
            router.push(vuln.path)
        } else if (onVulnerabilityClick) {
            onVulnerabilityClick(vuln)
        }
    }

    const handleNodeClick = (nodeId: string) => {
        router.push(`/nodes/${nodeId}`)
    }

    // Create hexagon path
    const getHexagonPath = (size: number) => {
        const points = []
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 2
            const x = size * Math.cos(angle)
            const y = size * Math.sin(angle)
            points.push(`${x},${y}`)
        }
        return `M ${points.join(' L ')} Z`
    }

    return (
        <div className="w-full aspect-[16/9] bg-[#0a0e14] rounded-lg border border-[#00ff9f]/20 shadow-[0_0_30px_rgba(0,255,159,0.15)] relative p-4">
            {/* Background grid pattern */}
            <div className="absolute inset-0 opacity-10 rounded-lg overflow-hidden">
                <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
                            <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#00ff9f" strokeWidth="0.5"/>
                        </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#grid)" />
                </svg>
            </div>

            <svg ref={svgRef} width="100%" height="100%" viewBox="0 0 900 600" style={{ overflow: 'visible' }} className="relative z-10">
                {/* Enhanced glow effects */}
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="5" result="coloredBlur" />
                        <feMerge>
                            <feMergeNode in="coloredBlur" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>
                    <filter id="glow-strong">
                        <feGaussianBlur stdDeviation="8" result="coloredBlur" />
                        <feMerge>
                            <feMergeNode in="coloredBlur" />
                            <feMergeNode in="coloredBlur" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>

                    {/* Animated gradient for connections */}
                    <linearGradient id="connection-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" stopColor="#00ff9f" stopOpacity="0.3">
                            <animate attributeName="stop-opacity" values="0.3;0.8;0.3" dur="2s" repeatCount="indefinite" />
                        </stop>
                        <stop offset="50%" stopColor="#00d9ff" stopOpacity="0.8">
                            <animate attributeName="offset" values="0.3;0.7;0.3" dur="2s" repeatCount="indefinite" />
                        </stop>
                        <stop offset="100%" stopColor="#00ff9f" stopOpacity="0.3">
                            <animate attributeName="stop-opacity" values="0.3;0.8;0.3" dur="2s" repeatCount="indefinite" />
                        </stop>
                    </linearGradient>
                </defs>

                {/* Edges - Enhanced with animated flow */}
                <g className="edges">
                    {edges.map((edge) => {
                        const isHighlighted = hoveredNode === edge.from || hoveredNode === edge.to
                        return (
                            <g key={`${edge.from}-${edge.to}`}>
                                {/* Shadow/glow layer */}
                                <path
                                    d={getEdgePath(edge.from, edge.to)}
                                    stroke={isHighlighted ? 'url(#connection-gradient)' : 'rgba(0, 255, 159, 0.2)'}
                                    className={edge.dashed ? 'stroke-dasharray-4' : ''}
                                    strokeWidth={isHighlighted ? '3' : '2'}
                                    fill="none"
                                    filter="url(#glow)"
                                    style={{ transition: 'all 0.3s ease' }}
                                />
                                {edge.label && (
                                    <text
                                        x={(nodePositions[edge.from]?.x + nodePositions[edge.to]?.x) / 2}
                                        y={(nodePositions[edge.from]?.y + nodePositions[edge.to]?.y) / 2}
                                        fill="#e8e9ed"
                                        className="text-xs font-mono"
                                        textAnchor="middle"
                                        dy={edge.label === 'Input' ? '10' :
                                            edge.label === 'Query' ? '10' :
                                                edge.label === 'Fine-tuning' ? '-25' :
                                                    '-8'}
                                    >
                                        {edge.label}
                                    </text>
                                )}
                            </g>
                        )
                    })}
                </g>

                {/* Nodes - Redesigned with hexagons */}
                <g className="nodes">
                    {nodes.map((node) => {
                        const pos = nodePositions[node.id]
                        if (!pos) return null
                        const Icon = node.icon
                        const isHovered = hoveredNode === node.id
                        const hexSize = (node.size || 40) * 0.85

                        return (
                            <g
                                key={node.id}
                                transform={`translate(${pos.x}, ${pos.y})`}
                                className="cursor-pointer transition-all duration-300"
                                onMouseEnter={() => setHoveredNode(node.id)}
                                onMouseLeave={() => setHoveredNode(null)}
                                onClick={() => handleNodeClick(node.id)}
                                style={{
                                    animation: `pulse-glow 2s ease-in-out infinite`,
                                    animationDelay: `${nodes.indexOf(node) * 0.2}s`
                                }}
                            >
                                {/* Outer hexagon glow */}
                                <path
                                    d={getHexagonPath(hexSize + 3)}
                                    fill="none"
                                    stroke={node.color}
                                    strokeWidth={isHovered ? 3 : 1}
                                    opacity={isHovered ? 0.6 : 0.3}
                                    filter="url(#glow-strong)"
                                    style={{ transition: 'all 0.3s ease' }}
                                />

                                {/* Main hexagon */}
                                <path
                                    d={getHexagonPath(hexSize)}
                                    fill="#0a0e14"
                                    stroke={node.color}
                                    strokeWidth={isHovered ? 3 : 2}
                                    filter="url(#glow)"
                                    style={{ transition: 'all 0.3s ease' }}
                                />

                                {/* Inner fill with gradient */}
                                <path
                                    d={getHexagonPath(hexSize - 2)}
                                    fill={`${node.color}08`}
                                    opacity={isHovered ? 0.3 : 0.1}
                                    style={{ transition: 'all 0.3s ease' }}
                                />

                                <text
                                    textAnchor="middle"
                                    fill="#e8e9ed"
                                    className="font-mono font-medium"
                                    fontSize={node.id === 'client' || node.id === 'security' || node.id === 'training' ? "9px" : "10px"}
                                    y={node.id === 'client' ? '-24' : node.id === 'security' || node.id === 'training' ? '-13' : '-12'}
                                >
                                    {node.id === 'client' ? (
                                        <>
                                            <tspan x="0" dy="0" className="font-medium">Client</tspan>
                                            <tspan x="0" dy="1.1em" className="font-medium">Malicious</tspan>
                                            <tspan x="0" dy="1.1em" className="font-medium">Actor</tspan>
                                        </>
                                    ) : node.id === 'security' ? (
                                        <>
                                            <tspan x="0" dy="0" className="font-medium">Security</tspan>
                                            <tspan x="0" dy="1.1em" className="font-medium">Layer</tspan>
                                        </>
                                    ) : node.id === 'training' ? (
                                        <>
                                            <tspan x="0" dy="0" className="font-medium">Training</tspan>
                                            <tspan x="0" dy="1.1em" className="font-medium">Pipeline</tspan>
                                        </>
                                    ) : (
                                        node.label.split('/').map((part, i) => (
                                            <tspan
                                                key={i}
                                                x="0"
                                                dy={i === 0 ? "0" : "1.1em"}
                                                className="font-medium"
                                            >
                                                {part}
                                            </tspan>
                                        ))
                                    )}
                                </text>
                                {Icon && (
                                    <Icon
                                        style={{
                                            transform: `translate(-14px, ${node.id === 'client' ? '8px' : node.id === 'security' || node.id === 'training' ? '6px' : '2px'})`,
                                            width: '28px',
                                            height: '28px',
                                            color: node.color,
                                            filter: isHovered ? `drop-shadow(0 0 8px ${node.color})` : 'none',
                                            transition: 'all 0.3s ease'
                                        }}
                                    />
                                )}
                            </g>
                        )
                    })}
                </g>

                {/* Vulnerabilities - Badges only (no tooltips yet) */}
                <g className="vulnerabilities">
                    {vulnerabilities.map((vuln) => {
                        const nodePos = nodePositions[vuln.position.node]
                        if (!nodePos) return null
                        const isHovered = hoveredVuln === vuln.id
                        const x = nodePos.x + vuln.position.offset.x
                        const y = nodePos.y + vuln.position.offset.y

                        return (
                            <g
                                key={vuln.id}
                                transform={`translate(${x}, ${y})`}
                                className="cursor-pointer transition-all duration-300"
                                onMouseEnter={() => setHoveredVuln(vuln.id)}
                                onMouseLeave={() => setHoveredVuln(null)}
                                onClick={() => handleVulnerabilityClick(vuln)}
                            >
                                {/* Outer glow */}
                                <rect
                                    x="-72"
                                    y="-22"
                                    width="144"
                                    height="44"
                                    rx="6"
                                    fill="none"
                                    stroke={vuln.color}
                                    strokeWidth={isHovered ? 2 : 1}
                                    opacity={isHovered ? 0.4 : 0.2}
                                    filter="url(#glow-strong)"
                                />

                                {/* Main box */}
                                <rect
                                    x="-70"
                                    y="-20"
                                    width="140"
                                    height="40"
                                    rx="4"
                                    fill="#0a0e14"
                                    stroke={vuln.color}
                                    strokeWidth={isHovered ? 3 : 2}
                                    filter="url(#glow)"
                                />

                                {/* Inner gradient fill */}
                                <rect
                                    x="-68"
                                    y="-18"
                                    width="136"
                                    height="36"
                                    rx="3"
                                    fill={`${vuln.color}08`}
                                    opacity={isHovered ? 0.3 : 0.1}
                                />

                                <text
                                    textAnchor="middle"
                                    fill={vuln.color}
                                    className="text-sm font-mono font-bold"
                                    y="6"
                                    style={{
                                        filter: isHovered ? `drop-shadow(0 0 6px ${vuln.color})` : 'none',
                                        transition: 'all 0.3s ease'
                                    }}
                                >
                                    {vuln.id}
                                </text>
                            </g>
                        )
                    })}
                </g>

                {/* Tooltips layer - rendered on top of everything */}
                <g className="vulnerability-tooltips">
                    {vulnerabilities.map((vuln) => {
                        const nodePos = nodePositions[vuln.position.node]
                        if (!nodePos) return null
                        const isHovered = hoveredVuln === vuln.id
                        if (!isHovered) return null

                        const x = nodePos.x + vuln.position.offset.x
                        const y = nodePos.y + vuln.position.offset.y

                        // Smart tooltip positioning based on vulnerability position
                        let tooltipX = -150
                        let tooltipY = -140

                        // If vulnerability is on the left side, show tooltip to the right
                        if (vuln.position.offset.x < 0) {
                            tooltipX = 80 // Show tooltip to the right of badge
                        }

                        // If vulnerability is low on screen, show tooltip above
                        if (vuln.position.offset.y > 0) {
                            tooltipY = -140 // Show above
                        } else {
                            tooltipY = 50 // Show below
                        }

                        return (
                            <g
                                key={`tooltip-${vuln.id}`}
                                transform={`translate(${x}, ${y})`}
                                className="pointer-events-none"
                            >
                                <foreignObject
                                    x={tooltipX}
                                    y={tooltipY}
                                    width="300"
                                    height="120"
                                    className="overflow-visible"
                                    style={{ overflow: 'visible' }}
                                >
                                    <div style={{
                                        background: '#1a1f2e',
                                        backdropFilter: 'blur(8px)',
                                        padding: '14px 18px',
                                        borderRadius: '8px',
                                        border: `2px solid ${vuln.color}`,
                                        boxShadow: `0 0 20px ${vuln.color}60, inset 0 0 20px ${vuln.color}10`,
                                        position: 'relative'
                                    }}>
                                        <p style={{ color: vuln.color }} className="text-sm font-mono font-bold mb-2">
                                            {vuln.title}
                                        </p>
                                        <p className="text-xs text-[#8892a6] leading-relaxed">
                                            {vuln.description}
                                        </p>
                                    </div>
                                </foreignObject>
                            </g>
                        )
                    })}
                </g>

                {/* Vulnerability Connectors */}
                <g className="connectors">
                    {vulnerabilities.map((vuln) => {
                        const nodePos = nodePositions[vuln.position.node]
                        if (!nodePos) return null
                        const isHovered = hoveredVuln === vuln.id || hoveredNode === vuln.position.node

                        return (
                            <path
                                key={`connector-${vuln.id}`}
                                d={getVulnerabilityConnector(nodePos, vuln.position.offset)}
                                stroke={vuln.color}
                                strokeWidth={isHovered ? 2 : 1}
                                strokeOpacity={isHovered ? 0.8 : 0.4}
                                fill="none"
                                strokeDasharray="4 4"
                                className="transition-all duration-300"
                            />
                        )
                    })}
                </g>
            </svg>
        </div>
    )
} 